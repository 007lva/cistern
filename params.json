{"name":"Cistern","tagline":"API client framework extracted from Fog","body":"# Cistern\r\n\r\n[![Build Status](https://secure.travis-ci.org/lanej/cistern.png)](http://travis-ci.org/lanej/cistern)\r\n[![Dependencies](https://gemnasium.com/lanej/cistern.png)](https://gemnasium.com/lanej/cistern.png)\r\n[![Gem Version](https://badge.fury.io/rb/cistern.svg)](http://badge.fury.io/rb/cistern)\r\n[![Code Climate](https://codeclimate.com/github/lanej/cistern/badges/gpa.svg)](https://codeclimate.com/github/lanej/cistern)\r\n\r\nCistern helps you consistently build your API clients and faciliates building mock support.\r\n\r\n## Usage\r\n\r\n### Custom Architecture\r\n\r\nBy default a service's `Request`, `Collection`, and `Model` are all classes. In Cistern ~> 3.0, the default will be modules.\r\n\r\nYou can modify your client's architecture to be forwards compatible by using `Cistern::Client.with`\r\n\r\n```ruby\r\nclass Foo::Client\r\n  include Cistern::Client.with(interface: :module)\r\nend\r\n```\r\n\r\nNow request classes would look like:\r\n\r\n```ruby\r\nclass Foo::GetBar\r\n  include Foo::Request\r\n\r\n  def real\r\n    \"bar\"\r\n  end\r\nend\r\n```\r\n\r\nOther options include `:collection`, `:request`, and `:model`.  This options define the name of module or class interface for the service component.\r\n\r\nIf `Request` is to reserved for a model, then the `Request` component name can be remapped to `Prayer`\r\n\r\nFor example:\r\n\r\n```ruby\r\nclass Foo::Client\r\n  include Cistern::Client.with(request: \"Prayer\")\r\nend\r\n```\r\n\r\nallows a model named `Request` to exist\r\n\r\n```ruby\r\nclass Foo::Request < Foo::Model\r\n  identity :jovi\r\nend\r\n```\r\n\r\nwhile living on a `Prayer`\r\n\r\n```ruby\r\nclass Foo::GetBar < Foo::Prayer\r\n  def real\r\n    service.request.get(\"/wing\")\r\n  end\r\nend\r\n```\r\n\r\n\r\n### Service\r\n\r\nThis represents the remote service that you are wrapping. If the service name is `foo` then a good name is `Foo::Client`.\r\n\r\nService initialization parameters are enumerated by `requires` and `recognizes`. Parameters defined using `recognizes` are optional.\r\n\r\n```ruby\r\nclass Foo::Client\r\n  include Cistern::Client\r\n\r\n  requires :hmac_id, :hmac_secret\r\n  recognizes :url\r\nend\r\n\r\n# Acceptable\r\nFoo::Client.new(hmac_id: \"1\", hmac_secret: \"2\")                            # Foo::Client::Real\r\nFoo::Client.new(hmac_id: \"1\", hmac_secret: \"2\", url: \"http://example.org\") # Foo::Client::Real\r\n\r\n# ArgumentError\r\nFoo::Client.new(hmac_id: \"1\", url: \"http://example.org\")\r\nFoo::Client.new(hmac_id: \"1\")\r\n```\r\n\r\nCistern will define for you two classes, `Mock` and `Real`.\r\n\r\n### Mocking\r\n\r\nCistern strongly encourages you to generate mock support for your service. Mocking can be enabled using `mock!`.\r\n\r\n```ruby\r\nFoo::Client.mocking?          # falsey\r\nreal = Foo::Client.new        # Foo::Client::Real\r\nFoo::Client.mock!\r\nFoo::Client.mocking?          # true\r\nfake = Foo::Client.new        # Foo::Client::Mock\r\nFoo::Client.unmock!\r\nFoo::Client.mocking?          # false\r\nreal.is_a?(Foo::Client::Real) # true\r\nfake.is_a?(Foo::Client::Mock) # true\r\n```\r\n\r\n### Requests\r\n\r\nRequests are defined by subclassing `#{service}::Request`.\r\n\r\n* `service` represents the associated `Foo::Client` instance.\r\n\r\n```ruby\r\nclass Foo::Client::GetBar < Foo::Client::Request\r\n  def real(params)\r\n    # make a real request\r\n    \"i'm real\"\r\n  end\r\n\r\n  def mock(params)\r\n    # return a fake response\r\n    \"imposter!\"\r\n  end\r\nend\r\n\r\nFoo::Client.new.get_bar # \"i'm real\"\r\n```\r\n\r\nThe `#service_method` function allows you to specify the name of the generated method.\r\n\r\n```ruby\r\nclass Foo::Client::GetBars < Foo::Client::Request\r\n  service_method :get_all_the_bars\r\n\r\n  def real(params)\r\n    \"all the bars\"\r\n  end\r\nend\r\n\r\nFoo::Client.new.respond_to?(:get_bars) # false\r\nFoo::Client.new.get_all_the_bars       # \"all the bars\"\r\n```\r\n\r\nAll declared requests can be listed via `Cistern::Client#requests`.\r\n\r\n```ruby\r\nFoo::Client.requests # => [Foo::Client::GetBars, Foo::Client::GetBar]\r\n```\r\n\r\n### Models\r\n\r\n* `service` represents the associated `Foo::Client` instance.\r\n* `collection` represents the related collection (if applicable)\r\n* `new_record?` checks if `identity` is present\r\n* `requires(*requirements)` throws `ArgumentError` if an attribute matching a requirement isn't set\r\n* `merge_attributes(attributes)` sets attributes for the current model instance\r\n\r\n#### Attributes\r\n\r\nAttributes are designed to be a flexible way of parsing service request responses.\r\n\r\n`identity` is special but not required.\r\n\r\n`attribute :flavor` makes `Foo::Client::Bar.new.respond_to?(:flavor)`\r\n\r\n* `:aliases` or `:alias` allows a attribute key to be different then a response key. `attribute :keypair_id, alias: \"keypair\"` with `merge_attributes(\"keypair\" => 1)` sets `keypair_id` to `1`\r\n* `:type` automatically casts the attribute do the specified type. `attribute :private_ips, type: :array` with `merge_attributes(\"private_ips\" => 2)` sets `private_ips` to `[2]`\r\n* `:squash` traverses nested hashes for a key. `attribute :keypair_id, aliases: \"keypair\", squash: \"id\"` with `merge_attributes(\"keypair\" => {\"id\" => 3})` sets `keypair_id` to `3`\r\n\r\nExample\r\n\r\n```ruby\r\nclass Foo::Client::Bar < Foo::Client::Model\r\n  identity :id\r\n\r\n  attribute :flavor\r\n  attribute :keypair_id, aliases: \"keypair\",  squash: \"id\"\r\n  attribute :private_ips, type: :array\r\n\r\n  def destroy\r\n    params  = {\r\n      \"id\" => self.identity\r\n    }\r\n    self.service.destroy_bar(params).body[\"request\"]\r\n  end\r\n\r\n  def save\r\n    requires :keypair_id\r\n\r\n    params = {\r\n      \"keypair\" => self.keypair_id,\r\n      \"bar\"     => {\r\n        \"flavor\" => self.flavor,\r\n      },\r\n    }\r\n\r\n    if new_record?\r\n      merge_attributes(service.create_bar(params).body[\"bar\"])\r\n    else\r\n      requires :identity\r\n\r\n      merge_attributes(service.update_bar(params).body[\"bar\"])\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n### Collection\r\n\r\n* `model` tells Cistern which class is contained within the collection.\r\n* `service` is the associated `Foo::Client` instance\r\n* `attribute` specifications on collections are allowed. use `merge_attributes`\r\n* `load` consumes an Array of data and constructs matching `model` instances\r\n\r\n```ruby\r\nclass Foo::Client::Bars < Foo::Client::Collection\r\n\r\n  attribute :count, type: :integer\r\n\r\n  model Foo::Client::Bar\r\n\r\n  def all(params = {})\r\n    response = service.get_bars(params)\r\n\r\n    data = response.body\r\n\r\n    self.load(data[\"bars\"])     # store bar records in collection\r\n    self.merge_attributes(data) # store any other attributes of the response on the collection\r\n  end\r\n\r\n  def discover(provisioned_id, options={})\r\n    params = {\r\n      \"provisioned_id\" => provisioned_id,\r\n    }\r\n    params.merge!(\"location\" => options[:location]) if options.key?(:location)\r\n\r\n    service.requests.new(service.discover_bar(params).body[\"request\"])\r\n  end\r\n\r\n  def get(id)\r\n    if data = service.get_bar(\"id\" => id).body[\"bar\"]\r\n      new(data)\r\n    else\r\n      nil\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n#### Data\r\n\r\nA uniform interface for mock data is mixed into the `Mock` class by default.\r\n\r\n```ruby\r\nFoo::Client.mock!\r\nclient = Foo::Client.new     # Foo::Client::Mock\r\nclient.data                  # Cistern::Data::Hash\r\nclient.data[\"bars\"] += [\"x\"] # [\"x\"]\r\n```\r\n\r\nMock data is class-level by default\r\n\r\n```ruby\r\nFoo::Client::Mock.data[\"bars\"] # [\"x\"]\r\n```\r\n\r\n`reset!` dimisses the `data` object.\r\n\r\n```ruby\r\nclient.data.object_id # 70199868585600\r\nclient.reset!\r\nclient.data[\"bars\"]   # []\r\nclient.data.object_id # 70199868566840\r\n```\r\n\r\n`clear` removes existing keys and values but keeps the same object.\r\n\r\n```ruby\r\nclient.data[\"bars\"] += [\"y\"] # [\"y\"]\r\nclient.data.object_id        # 70199868378300\r\nclient.clear\r\nclient.data[\"bars\"]          # []\r\nclient.data.object_id        # 70199868378300\r\n```\r\n\r\n* `store` and `[]=` write\r\n* `fetch` and `[]` read\r\n\r\nYou can make the service bypass Cistern's mock data structures by simply creating a `self.data` function in your service `Mock` declaration.\r\n\r\n```ruby\r\nclass Foo::Client\r\n  include Cistern::Client\r\n\r\n  class Mock\r\n    def self.data\r\n      @data ||= {}\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n#### Storage\r\n\r\nCurrently supported storage backends are:\r\n\r\n* `:hash` : `Cistern::Data::Hash` (default)\r\n* `:redis` : `Cistern::Data::Redis`\r\n\r\n\r\nBackends can be switched by using `store_in`.\r\n\r\n```ruby\r\n# use redis with defaults\r\nPatient::Mock.store_in(:redis)\r\n# use redis with a specific client\r\nPatient::Mock.store_in(:redis, client: Redis::Namespace.new(\"cistern\", redis: Redis.new(host: \"10.1.0.1\"))\r\n# use a hash\r\nPatient::Mock.store_in(:hash)\r\n```\r\n\r\n\r\n#### Dirty\r\n\r\nDirty attributes are tracked and cleared when `merge_attributes` is called.\r\n\r\n* `changed` returns a Hash of changed attributes mapped to there initial value and current value\r\n* `dirty_attributes` returns Hash of changed attributes with there current value.  This should be used in the model `save` function.\r\n\r\n\r\n```ruby\r\nbar = Foo::Client::Bar.new(id: 1, flavor: \"x\") # => <#Foo::Client::Bar>\r\n\r\nbar.dirty?           # => false\r\nbar.changed          # => {}\r\nbar.dirty_attributes # => {}\r\n\r\nbar.flavor = \"y\"\r\n\r\nbar.dirty?           # => true\r\nbar.changed          # => {flavor: [\"x\", \"y\"]}\r\nbar.dirty_attributes # => {flavor: \"y\"}\r\n\r\nbar.save\r\nbar.dirty?           # => false\r\nbar.changed          # => {}\r\nbar.dirty_attributes # => {}\r\n```\r\n\r\n## Examples\r\n\r\n* [zendesk2](https://github.com/lanej/zendesk2)\r\n* [you_track](https://github.com/lanej/you_track)\r\n\r\n## Releasing\r\n\r\n    $ gem bump -trv (major|minor|patch)\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Added some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"UA-36625285-1 Joshua Lane","note":"Don't delete this file! It's used internally to help with page regeneration."}